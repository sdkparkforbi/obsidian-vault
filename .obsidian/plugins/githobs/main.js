/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => GitHobs
});
module.exports = __toCommonJS(main_exports);

// src/migrations/supportMultipleRepos.ts
function supportMultipleRepos(settings) {
  if (settings.version) {
    return settings;
  }
  const newSettings = {};
  newSettings.token = settings.token;
  newSettings.repos = [
    { owner: settings.owner, repo: settings.repo, code: `${settings.owner}|${settings.repo}` }
  ];
  newSettings.version = 1;
  return newSettings;
}

// src/settings.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  version: 1,
  token: "",
  repos: []
};
function createFormSetting(plugin, container, args) {
  const { name, description, placeholder } = args;
  const { value, onChange } = args;
  new import_obsidian.Setting(container).setName(name).setDesc(description != null ? description : "").addText(
    (text) => text.setPlaceholder(placeholder != null ? placeholder : "").setValue(value).onChange(async (val) => {
      onChange(val);
      await plugin.saveSettings();
    })
  );
}
var SettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl, plugin } = this;
    const settingsValues = plugin.settings;
    containerEl.empty();
    const createDescriptionWithLink = ({
      text,
      href,
      aText
    }) => {
      const fragment = document.createDocumentFragment();
      const div3 = fragment.createDiv({ text });
      div3.createEl("a", { href, text: aText });
      fragment.append(div3);
      return fragment;
    };
    createFormSetting(plugin, containerEl, {
      name: "Github Token",
      description: createDescriptionWithLink({
        href: "https://github.com/settings/tokens/new",
        text: "Add the github token, alternately ",
        aText: "create one"
      }),
      placeholder: "Enter your secret",
      value: settingsValues.token,
      onChange: (val) => plugin.settings.token = val
    });
    const div = containerEl.createDiv({ cls: "setting-item" });
    const div1 = div.createDiv({ cls: "setting-item-info" });
    div1.createEl("strong", { text: "Repos Manager" });
    const div2 = div.createDiv({ cls: "settings-item-control" });
    const addRepoBtn = div2.createEl("button", { text: "Add", cls: "mod-cta" });
    addRepoBtn.onclick = async () => {
      settingsValues.repos = [...settingsValues.repos, { owner: "", repo: "", code: "" }];
      await plugin.saveSettings();
      this.display();
    };
    settingsValues.repos.forEach((repo, idx) => {
      createFormSetting(plugin, containerEl, {
        name: "Owner",
        value: repo.owner,
        onChange: (val) => {
          plugin.settings.repos[idx].owner = val.trim();
        }
      });
      createFormSetting(plugin, containerEl, {
        name: "Repo",
        value: repo.repo,
        onChange: (val) => {
          plugin.settings.repos[idx].repo = val.trim();
          plugin.settings.repos[idx].code = `${plugin.settings.repos[idx].owner}|${val}`;
        }
      });
      const containerRemoveBtn = containerEl.createEl("div", { cls: "setting-item" });
      const removeRepoBtn = containerRemoveBtn.createEl("button", {
        text: "Remove",
        cls: ["mod-warning", "githobs-delete-repo-btn"]
      });
      removeRepoBtn.onclick = async () => {
        settingsValues.repos = settingsValues.repos.filter((_, sIdx) => sIdx !== idx);
        await plugin.saveSettings();
        this.display();
      };
    });
  }
};

// src/helper/migrations.ts
var MIGRATIONS = [supportMultipleRepos];
function migrate(settings) {
  var _a;
  if (!settings || Object.keys(settings).length === 0) {
    return {
      newSettings: DEFAULT_SETTINGS,
      migrationsApplied: true
    };
  }
  const migrationsToApply = MIGRATIONS.splice((_a = settings.version) != null ? _a : 0);
  if (migrationsToApply.length === 0) {
    return { newSettings: settings, migrationsApplied: false };
  }
  let newSettings = settings;
  for (const migration of migrationsToApply) {
    newSettings = migration(newSettings);
  }
  return { newSettings, migrationsApplied: true };
}

// src/main.ts
var import_obsidian5 = require("obsidian");

// src/view/index.ts
var import_obsidian4 = require("obsidian");

// src/helper/properties.ts
var PROPERTIES = {
  issue: "github_issue",
  repo: "github_repo"
};
var PROPERTIES_DELIMITER = "---";
function readProperties(data) {
  if (!data) {
    return { properties: void 0, indexEndPropertiesLine: void 0 };
  }
  const [firstLine, ...restOfLines] = data.split("\n");
  if (firstLine !== PROPERTIES_DELIMITER) {
    return { properties: void 0, indexEndPropertiesLine: void 0 };
  }
  const indexEndPropertiesLine = restOfLines.indexOf(PROPERTIES_DELIMITER);
  if (!indexEndPropertiesLine) {
    return { properties: void 0, indexEndPropertiesLine: void 0 };
  }
  return {
    properties: restOfLines.slice(0, indexEndPropertiesLine),
    indexEndPropertiesLine: indexEndPropertiesLine + 1
  };
}
function removeProperties(data) {
  const { indexEndPropertiesLine } = readProperties(data);
  if (!indexEndPropertiesLine) return data;
  const dataSplitted = data.split("\n");
  return dataSplitted.slice(indexEndPropertiesLine + 1).join("\n");
}
function readProperty(data, key) {
  const { properties } = readProperties(data);
  if (!properties) return;
  const githubIssueProperty = properties.find((p) => p.startsWith(key));
  if (!githubIssueProperty) return;
  const [, value] = githubIssueProperty.split(": ");
  return value;
}
async function writeProperty(data, file, key, value) {
  const { properties } = readProperties(data);
  const newProperties = [
    PROPERTIES_DELIMITER,
    ...properties ? [...properties.filter((p) => !p.includes(key))] : [],
    `${key}: ${value}`,
    PROPERTIES_DELIMITER
  ].join("\n");
  const fullFile = `${newProperties}
${removeProperties(data)}`;
  await this.app.vault.modify(file, fullFile);
  return fullFile;
}

// src/helper/title.ts
var INVALID_CHAR_OBSIDIAN_TITLE = ["/", "\\", ":", "|", "^", "#", "[", "]", "?"];
function isInvalid(title) {
  return INVALID_CHAR_OBSIDIAN_TITLE.some((char) => title.includes(char));
}
function sanitize(title) {
  if (isInvalid(title)) {
    const allChars = title.split("");
    const sanitated = allChars.map((c) => isInvalid(c) ? encodeURIComponent(c) : c);
    return sanitated.join("");
  }
  return decodeURIComponent(title);
}

// src/api.ts
var import_obsidian2 = require("obsidian");
async function createIssue(settings, body, selectedRepo) {
  const repo = settings.repos.find((r) => r.code === selectedRepo);
  if (!repo) {
    new import_obsidian2.Notice("Select repo!");
    return;
  }
  const res = await (0, import_obsidian2.requestUrl)({
    url: `https://api.github.com/repos/${repo.owner}/${repo.repo}/issues`,
    headers: { Authorization: `Bearer ${settings.token}` },
    method: "POST",
    body: JSON.stringify(body)
  });
  if (res.status === 201) {
    new import_obsidian2.Notice("Issue successfully created");
  }
  return res;
}
async function updateIssue(settings, issueId, body, selectedRepo) {
  const repo = settings.repos.find((r) => r.code === selectedRepo);
  if (!repo) {
    new import_obsidian2.Notice("Select repo!");
    return;
  }
  const res = await (0, import_obsidian2.requestUrl)({
    url: `https://api.github.com/repos/${repo.owner}/${repo.repo}/issues/${issueId}`,
    headers: { Authorization: `Bearer ${settings.token}` },
    method: "PATCH",
    body: JSON.stringify(body)
  });
  if (res.status === 200) {
    new import_obsidian2.Notice("Issue successfully updated");
  }
  return res;
}
async function getIssue(settings, issueId, selectedRepo) {
  const repo = settings.repos.find((r) => r.code === selectedRepo);
  if (!repo) {
    new import_obsidian2.Notice("Select repo!");
    return;
  }
  const res = await (0, import_obsidian2.requestUrl)({
    url: `https://api.github.com/repos/${repo.owner}/${repo.repo}/issues/${issueId}`,
    headers: { Authorization: `Bearer ${settings.token}` },
    method: "GET"
  });
  return res;
}

// src/view/actions.ts
var import_obsidian3 = require("obsidian");
async function updateFile(file, res) {
  var _a, _b;
  if (res == null ? void 0 : res.json.title) {
    const title = sanitize(res == null ? void 0 : res.json.title);
    await this.app.vault.rename(
      file,
      ((_a = file == null ? void 0 : file.parent) == null ? void 0 : _a.path) === "/" ? `${title}.md` : `${(_b = file == null ? void 0 : file.parent) == null ? void 0 : _b.path}/${title}.md`
    );
  }
  if (res) {
    const contentOfFile = await this.app.vault.read(file);
    const { properties } = readProperties(contentOfFile);
    const formattedProperties = (properties ? [
      PROPERTIES_DELIMITER,
      ...properties,
      PROPERTIES_DELIMITER
    ] : []).join("\n");
    const propertiesWithGithubIssueNumber = await writeProperty(
      formattedProperties,
      file,
      PROPERTIES.issue,
      res.json.number
    );
    await this.app.vault.modify(file, `${propertiesWithGithubIssueNumber}${res.json.body}`, {
      mtime: new Date(res.json.updated_at).getTime()
    });
  }
}
async function pushIssue(issueId, file, settings, selectedRepo) {
  const contentOfFile = await this.app.vault.read(file);
  const title = sanitize(file.basename);
  if (issueId) {
    const res2 = await updateIssue(
      settings,
      issueId,
      {
        title,
        body: removeProperties(contentOfFile)
      },
      selectedRepo
    );
    if ((res2 == null ? void 0 : res2.status) === 200) {
      await updateFile(file, res2);
    }
    return;
  }
  const res = await createIssue(
    settings,
    {
      title,
      body: removeProperties(contentOfFile)
    },
    selectedRepo
  );
  if ((res == null ? void 0 : res.status) === 201) {
    await updateFile(file, res);
  }
}
async function fetchIssue(issueId, settings, file, selectedRepo) {
  const res = await getIssue(settings, issueId, selectedRepo);
  const fileRead = this.app.vault.getFiles().find((f) => f.path === file.path);
  const lastDate = fileRead.stat.mtime;
  let status = void 0;
  if (lastDate && new Date(res == null ? void 0 : res.json.updated_at) > new Date(lastDate)) {
    status = "can-pull" /* CanPull */;
  }
  if (lastDate && new Date(res == null ? void 0 : res.json.updated_at) < new Date(lastDate)) {
    status = "can-push" /* CanPush */;
  }
  return { date: res == null ? void 0 : res.json.updated_at, status };
}
async function pullIssue(issueId, file, settings, selectedRepo) {
  const res = await getIssue(settings, issueId, selectedRepo);
  await updateFile(file, res);
}
async function changeIssueId(issueId, file, settings, selectedRepo) {
  try {
    await pullIssue(issueId, file, settings, selectedRepo);
    new import_obsidian3.Notice("Issue changed!");
  } catch (err) {
    new import_obsidian3.Notice(err);
  }
}

// src/view/index.ts
var GithubIssueControlsViewType = "github-issue-controls-view";
var GithubIssueControlsView = class extends import_obsidian4.ItemView {
  constructor(leaf, settings) {
    super(leaf);
    this.draw = async () => {
      var _a, _b;
      const obContainer = this.containerEl.children[1];
      const activeFile = this.app.workspace.getActiveFile();
      const editor = this.leaf.view.app.workspace.getActiveViewOfType(import_obsidian4.MarkdownView);
      if (!activeFile) {
        obContainer.empty();
        return;
      }
      const rootElement = document.createElement("div");
      const contentOfFile = await this.app.vault.read(activeFile);
      this.setIssueId(
        readProperty(contentOfFile, PROPERTIES.issue)
      );
      this.setSelectedRepo(
        readProperty(contentOfFile, PROPERTIES.repo)
      );
      const viewContainer = createContainer(rootElement);
      if (!this.settings.token || this.settings.repos.length === 0) {
        obContainer.empty();
        createSection(
          viewContainer,
          {
            info: "Missing settings! \u{1F6A8}",
            description: { text: "Please setup settings first" }
          },
          true
        );
        createSection(viewContainer, {
          info: "Reload",
          button: {
            icon: "refresh-ccw",
            action: async () => {
              this.reload(editor);
            }
          }
        });
        obContainer.appendChild(viewContainer);
        return;
      }
      const issueUrl = (() => {
        const repo = this.settings.repos.find((r) => r.code === this.selectedRepo);
        if (!repo || !this.issueId) {
          return;
        }
        return `https://github.com/${repo == null ? void 0 : repo.owner}/${repo == null ? void 0 : repo.repo}/issues/${this.issueId}`;
      })();
      createSection(
        viewContainer,
        {
          info: "Issue Editor \u{1F9A4}",
          ...issueUrl && {
            description: {
              text: "Original: ",
              linkText: sanitize(activeFile.basename),
              linkUrl: issueUrl
            }
          }
        },
        true
      );
      createSection(viewContainer, {
        info: "Repo",
        dropdown: {
          items: [{ repo: "", code: "" }, ...this.settings.repos].map((r) => ({
            text: r.repo,
            value: r.code
          })),
          value: this.selectedRepo,
          onChange: async (val) => {
            this.setSelectedRepo(val);
            const contentOfFile2 = await this.app.vault.read(activeFile);
            await writeProperty(
              contentOfFile2,
              activeFile,
              PROPERTIES.repo,
              val
            );
          }
        }
      });
      createSection(viewContainer, {
        info: "Issue number:",
        button: {
          icon: "crosshair",
          action: async () => {
            if (!this.issueId) {
              new import_obsidian4.Notice("Select a issue id");
              return;
            }
            if (!this.selectedRepo) {
              new import_obsidian4.Notice("Select a repo");
              return;
            }
            return await changeIssueId(
              this.issueId,
              activeFile,
              this.settings,
              this.selectedRepo
            );
          }
        },
        input: {
          value: (_b = (_a = this.issueId) == null ? void 0 : _a.trim()) != null ? _b : "",
          type: "number",
          onChange: async (val) => this.setIssueId(val)
        }
      });
      createSection(viewContainer, {
        info: "Fetch",
        description: { text: this.issueId ? this.fetchDate : "First push" },
        button: {
          icon: "refresh-ccw",
          action: async () => {
            if (!this.issueId || !this.selectedRepo) {
              return;
            }
            const fetchedIssue = await fetchIssue(
              this.issueId,
              this.settings,
              activeFile,
              this.selectedRepo
            );
            this.setFetchDate(fetchedIssue.date);
            this.status = fetchedIssue.status;
            this.reload(editor);
          }
        }
      });
      createSection(viewContainer, {
        info: "Push",
        description: this.status === "can-push" /* CanPush */ ? { text: "\u{1F7E2} Changes can be pushed" } : void 0,
        button: {
          icon: "upload",
          action: async () => {
            if (!this.selectedRepo) {
              new import_obsidian4.Notice("Select a repo");
              return;
            }
            await pushIssue(this.issueId, activeFile, this.settings, this.selectedRepo);
            this.status = void 0;
            this.reload(editor);
          }
        }
      });
      if (this.issueId) {
        createSection(viewContainer, {
          info: "Pull",
          description: this.status === "can-pull" /* CanPull */ ? { text: "\u{1F534} New version available" } : void 0,
          button: {
            icon: "download",
            action: async () => {
              if (!this.selectedRepo) {
                new import_obsidian4.Notice("Select a repo");
                return;
              }
              await pullIssue(
                this.issueId,
                activeFile,
                this.settings,
                this.selectedRepo
              );
              this.status = void 0;
              this.reload(editor);
            }
          }
        });
      }
      obContainer.empty();
      obContainer.appendChild(viewContainer);
    };
    this.settings = settings;
  }
  getViewType() {
    return GithubIssueControlsViewType;
  }
  getDisplayText() {
    return "Github Issue Controls";
  }
  getIcon() {
    return "github";
  }
  load() {
    super.load();
    this.fetchDate = void 0;
    this.status = void 0;
    this.issueId = void 0;
    this.selectedRepo = void 0;
    this.draw();
  }
  setFetchDate(fetchDate) {
    this.fetchDate = fetchDate;
  }
  setIssueId(issueId) {
    this.issueId = issueId;
  }
  setSelectedRepo(selectedRepo) {
    this.selectedRepo = selectedRepo;
  }
  reload(editor) {
    editor == null ? void 0 : editor.editor.focus();
    this.draw();
  }
};
function createContainer(rootEl) {
  const c = rootEl.createDiv({ cls: "vertical-tab-content-container" });
  return c;
}
function createSection(containerToAppend, {
  info,
  description,
  button,
  dropdown,
  input
}, headerInfo = false) {
  var _a;
  let i;
  if (!headerInfo) {
    i = containerToAppend.createDiv({ cls: "setting-item" });
  } else {
    i = containerToAppend.createDiv({ cls: "setting-item setting-item-heading" });
  }
  const infoElement = i.createDiv({ cls: "setting-item-info" });
  infoElement.createDiv({ cls: "setting-item-name", text: info });
  if (description == null ? void 0 : description.text) {
    const descEl = infoElement.createDiv({
      cls: "setting-item-description",
      text: description.text
    });
    if (description.textBold) {
      descEl.createEl("strong", { text: description.textBold });
    }
    if (description.linkText && description.linkUrl) {
      descEl.createEl("a", { text: description.linkText, href: description.linkUrl });
    }
  }
  let settingControl;
  if (button || dropdown || input) {
    settingControl = i.createDiv({ cls: "setting-item-control" });
    if (input) {
      const inputEl = settingControl.createEl("input", { cls: "githobs-input" });
      inputEl.setAttribute("type", input.type);
      inputEl.setAttribute("value", input.value);
      inputEl.onchange = (val) => {
        var _a2;
        input.onChange((_a2 = val.target) == null ? void 0 : _a2.value);
      };
    }
    if (dropdown) {
      const select = settingControl.createEl("select");
      select.className = "dropdown";
      dropdown.items.forEach((i2) => {
        const o = select.createEl("option", { text: i2.text });
        o.setAttribute("value", i2.value);
      });
      select.onchange = (val) => {
        dropdown.onChange(val.target.value);
      };
      select.value = (_a = dropdown.value) != null ? _a : "";
    }
    if (button) {
      const btn = settingControl.createEl("button");
      (0, import_obsidian4.setIcon)(btn, button.icon);
      btn.onclick = async () => {
        (0, import_obsidian4.setIcon)(btn, "hourglass");
        btn.setAttr("disabled", "");
        await button.action();
        (0, import_obsidian4.setIcon)(btn, button.icon);
        btn.removeAttribute("disabled");
      };
    }
  }
  return i;
}

// src/main.ts
var GitHobs = class extends import_obsidian5.Plugin {
  constructor() {
    super(...arguments);
    this.toggleGitHubIssueControlsView = async () => {
      const existing = this.app.workspace.getLeavesOfType(GithubIssueControlsViewType);
      if (existing.length) {
        this.app.workspace.revealLeaf(existing[0]);
        return;
      }
      await this.app.workspace.getRightLeaf(false).setViewState({
        type: GithubIssueControlsViewType,
        active: true
      });
      this.app.workspace.revealLeaf(
        this.app.workspace.getLeavesOfType(GithubIssueControlsViewType)[0]
      );
    };
  }
  async onload() {
    await this.loadSettings();
    this.registerView(
      GithubIssueControlsViewType,
      (leaf) => this.gitHubIssueControlsView = new GithubIssueControlsView(leaf, this.settings)
    );
    this.addRibbonIcon("github", "Manage a github issue", async () => {
      this.toggleGitHubIssueControlsView();
    });
    this.addSettingTab(new SettingTab(this.app, this));
    this.registerEvent(
      this.app.workspace.on("file-open", () => this.gitHubIssueControlsView.load())
    );
  }
  onunload() {
  }
  async loadSettings() {
    const originalSettings = await this.loadData();
    const { newSettings, migrationsApplied } = migrate(originalSettings);
    if (migrationsApplied) {
      await this.saveData(newSettings);
    }
    this.settings = newSettings;
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};

/* nosourcemap */